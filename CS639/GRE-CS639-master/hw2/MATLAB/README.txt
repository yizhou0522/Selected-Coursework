1b - generateHoughAccumulator():
I decided to use 240 as the theta bin number and 800 as the rho bin number. The reason to use them is mainly because that the maximum possible diagonal is around 800 pixels and we view a bin to approximately 0.75 degree. Then, given the fact that the range of angle is 180 degrees, we get 180/0.75=240. Similarly, since rho has a range of 800, we pick 800 as the value of rho.
Voting Scheme: Instead of using a patch of few surrounding bins, each bin in the accumulator arrays is used to vote. By a number of trials and errors, we found that the selected resolution is accurate and not too low to reduce the precision or too high to be inefficient.

1c - lineFinder(): 
Regarding finding the peak, I simply used the standard threshold method to get these Hough     peaks. To be specific, we first check if the accumulator arrays, given by 1b, are larger than threshold value, then calculate theta and rho based on it, and finally use line() method to plot the lines. By a series of experiments, I finally selected [120, 50, 60] as the threshold values. These values won’t cause too much overlapping on the same edge and it has the ability to detect the majority of edges.


 1d - lineSegmentFinder():
To  detect the end-points of line segments in the image, I first employed lineFinder() method to get the line_detected_image as well as the edge_image. The corresponding image is then analyzed for a non-zero value for each line returned by lineFinder(), at any position on the line. When this value is not negative, the end point of the line is stored and the method proceeds to detect the other end point where the pixels in the image are negative. One thing needs to point out is that the algorithm described above is definitely not perfect, but it indeed provides some meaningful results (see the croppedline_hough.img).